import { type AlignedValue, type CoinPublicKey, type ContractAddress, type ContractState, type Op, type StateValue, type ZswapLocalState } from '@midnight-ntwrk/compact-runtime';
import type { Transcript } from '@midnight-ntwrk/ledger';
import type { CircuitParameters, CircuitReturnType, Contract, ImpureCircuitId } from './contract-model';
/**
 * Base type for a circuit call configuration.
 */
export type CallOptionsBase<C extends Contract, ICK extends ImpureCircuitId<C>> = {
    /**
     * The contract defining the circuit to call.
     */
    readonly contract: C;
    /**
     * The identifier of the circuit to call.
     */
    readonly circuitId: ICK;
    /**
     * The address of the contract being executed.
     */
    readonly contractAddress: ContractAddress;
};
/**
 * Conditional type that optionally adds the inferred circuit argument types to
 * a circuit call configuration.
 */
export type CallOptionsBaseWithArguments<C extends Contract, ICK extends ImpureCircuitId<C>> = CircuitParameters<C, ICK> extends [] ? CallOptionsBase<C, ICK> : CallOptionsBase<C, ICK> & {
    /**
     * Arguments to pass to the circuit being called.
     */
    readonly args: CircuitParameters<C, ICK>;
};
/**
 * Complete configuration for a circuit call.
 */
export type CallOptions<PS, C extends Contract<PS>, ICK extends ImpureCircuitId<C>> = CallOptionsBaseWithArguments<C, ICK> & {
    /**
     * The current user's ZSwap public key.
     */
    coinPublicKey: CoinPublicKey;
    /**
     * The public state to run the circuit against.
     */
    initialContractState: ContractState;
    /**
     * The private state to run the circuit against.
     */
    initialPrivateState: PS;
};
/**
 * The private (sensitive) portions of the call result.
 */
export type CallResultPrivate<PS, C extends Contract<PS>, ICK extends ImpureCircuitId<C>> = {
    /**
     * ZK representation of the circuit arguments.
     */
    readonly input: AlignedValue;
    /**
     * ZK representation of the circuit result.
     */
    readonly output: AlignedValue;
    /**
     * ZK representation of the circuit witness call results.
     */
    readonly privateTranscriptOutputs: AlignedValue[];
    /**
     * The JS representation of the input to the circuit.
     */
    readonly result: CircuitReturnType<C, ICK>;
    /**
     * The private state resulting from executing the circuit.
     */
    readonly nextPrivateState: PS;
    /**
     * The Zswap local state resulting from executing the circuit.
     */
    readonly nextZswapLocalState: ZswapLocalState;
};
/**
 * Convenience type for result returned from {@link partitionTranscripts}.
 */
export type PartitionedTranscript = [
    Transcript<AlignedValue> | undefined,
    Transcript<AlignedValue> | undefined
];
/**
 * The public portions of the call result.
 */
export type CallResultPublic = {
    /**
     * The public state resulting from executing the circuit.
     */
    readonly nextContractState: StateValue;
    /**
     * The public transcript resulting from executing the circuit.
     */
    readonly publicTranscript: Op<AlignedValue>[];
    /**
     * A {@link publicTranscript} partitioned into guaranteed and fallible sections.
     * The guaranteed section of a public transcript must succeed for the corresponding
     * transaction to be considered valid. The fallible section of a public transcript
     * can fail without invalidating the transaction, as long as the guaranteed section succeeds.
     */
    readonly partitionedTranscript: PartitionedTranscript;
};
/**
 * Contains all information resulting from circuit execution.
 */
export type CallResult<PS, C extends Contract<PS>, ICK extends ImpureCircuitId<C>> = {
    /**
     * The public/non-sensitive data produced by the circuit execution.
     */
    readonly public: CallResultPublic;
    /**
     * The private/sensitive data produced by the circuit execution.
     */
    readonly private: CallResultPrivate<PS, C, ICK>;
};
/**
 * Calls a circuit in the given contract according to the given configuration.
 *
 * @param options Configuration.
 */
export declare const call: <PS, C extends Contract<PS>, ICK extends ImpureCircuitId<C>>(options: CallOptions<PS, C, ICK>) => CallResult<PS, C, ICK>;
//# sourceMappingURL=call.d.ts.map