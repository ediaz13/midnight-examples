import type { MidnightProviders, PrivateStateSchema, PrivateStateKey } from '@midnight-ntwrk/midnight-js-types';
import { type SigningKey } from '@midnight-ntwrk/compact-runtime';
import { type Contract, type ImpureCircuitId } from './contract-model';
import { type DeployTxOptionsBaseWithArguments } from './unproven-deploy-tx';
import type { FinalizedDeployTxData } from './tx-model';
import type { FoundContract } from './find-deployed-contract';
/**
 * Configuration for {@link deployContract}.
 */
export type DeployContractOptions<PSS extends PrivateStateSchema, PSK extends PrivateStateKey<PSS>, C extends Contract<PSS[PSK]>> = DeployTxOptionsBaseWithArguments<PSS[PSK], C> & {
    /**
     * An identifier for the private state of the contract being deployed.
     */
    readonly privateStateKey: PSK;
    /**
     * The signing key to add as the to-be-deployed contract's maintenance authority.
     * If undefined, a new signing key is sampled and used as the CMA then stored
     * in the private state provider under the newly deployed contract's address.
     * Otherwise, the passed signing key is added as the CMA. The second case is
     * useful when you want to use the same CMA for two different contracts.
     */
    readonly signingKey?: SigningKey;
};
/**
 * Interface for a contract that has been deployed to the blockchain.
 */
export type DeployedContract<PS, C extends Contract<PS>> = FoundContract<PS, C> & {
    /**
     * Data resulting from the deployment transaction that created this contract. The information in a
     * {@link DeployedContract.deployTxData} contains additional private information that does not
     * exist in {@link FoundContract.deployTxData} because certain private data is only available to
     * the deployer of a contract.
     */
    readonly deployTxData: FinalizedDeployTxData<PS>;
};
/**
 * Creates and submits a contract deployment transaction. This function is the entry point for the transaction
 * construction workflow and is used to create a {@link DeployedContract} instance.
 *
 * @param providers The providers used to manage the transaction lifecycle.
 * @param options Configuration.
 *
 * @throws DeployTxFailedError If the transaction is submitted successfully but produces an error
 *                        when executed by the node.
 */
export declare const deployContract: <PSS extends PrivateStateSchema, PSK extends PrivateStateKey<PSS>, C extends Contract<PSS[PSK]>>(providers: MidnightProviders<ImpureCircuitId<C>, PSS>, options: DeployContractOptions<PSS, PSK, C>) => Promise<DeployedContract<PSS[PSK], C>>;
//# sourceMappingURL=deploy-contract.d.ts.map