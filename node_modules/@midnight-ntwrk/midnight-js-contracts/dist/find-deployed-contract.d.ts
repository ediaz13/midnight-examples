import type { MidnightProviders, PrivateStateKey, PrivateStateSchema, VerifierKey } from '@midnight-ntwrk/midnight-js-types';
import { type ContractAddress, type ContractState, type SigningKey } from '@midnight-ntwrk/compact-runtime';
import { type Contract, type ImpureCircuitId } from './contract-model';
import { type CircuitCallTxInterface, type CircuitMaintenanceTxInterfaces, type ContractMaintenanceTxInterface } from './tx-interfaces';
import type { FinalizedDeployTxDataBase } from './tx-model';
/**
 * Checks that two verifier keys are equal. Does initial length check match for efficiency.
 *
 * @param a First verifier key.
 * @param b Second verifier key.
 */
export declare const verifierKeysEqual: (a: Uint8Array, b: Uint8Array) => boolean;
/**
 * Checks that the given `contractState` contains the given `verifierKeys`.
 *
 * @param verifierKeys The verifier keys the client has for the deployed contract we're checking.
 * @param contractState The (typically already deployed) contract state containing verifier keys.
 *
 * @throws ContractTypeError When one or more of the local and deployed verifier keys do not match.
 */
export declare const verifyContractState: (verifierKeys: [ImpureCircuitId, VerifierKey][], contractState: ContractState) => void;
/**
 * Configuration for {@link findDeployedContract}.
 */
export type FindDeployedContractOptions<PSS extends PrivateStateSchema, PSK extends PrivateStateKey<PSS>, C extends Contract<PSS[PSK]>> = {
    /**
     * The contract to use to execute circuits.
     */
    readonly contract: C;
    /**
     * The address of a previously deployed contract.
     */
    readonly contractAddress: ContractAddress;
    /**
     * An identifier for the private state of the contract being found.
     */
    readonly privateStateKey: PSK;
    /**
     * The initial private state to use. If undefined {@link findDeployedContract}
     * requires there to be a pre-existing private state at the `privateStateKey`.
     * If defined {@link findDeployedContract} requires there not to be a
     * pre-existing private state.
     */
    readonly initialPrivateState?: PSS[PSK];
    /**
     * The signing key to use to perform contract maintenance updates. If defined, the given signing
     * key is stored for this contract address. This is useful when someone has already added the given signing
     * key to the contract maintenance authority. If undefined, and there is an existing signing key for the
     * contract address locally, the existing signing key is kept. This is useful when the contract was
     * deployed locally. If undefined, and there is not an existing signing key for the contract address
     * locally, a fresh signing key is generated and stored for the contract address locally. This is
     * useful when you want to give a signing key to someone else to add you as a maintenance authority.
     */
    readonly signingKey?: SigningKey;
};
/**
 * Base type for a deployed contract that has been found on the blockchain.
 */
export type FoundContract<PS, C extends Contract<PS>> = {
    /**
     * Data for the finalized deploy transaction corresponding to this contract.
     */
    readonly deployTxData: FinalizedDeployTxDataBase<PS>;
    /**
     * Interface for creating call transactions for a contract.
     */
    readonly callTx: CircuitCallTxInterface<PS, C>;
    /**
     * An interface for creating maintenance transactions for circuits defined in the
     * contract that was deployed.
     */
    readonly circuitMaintenanceTx: CircuitMaintenanceTxInterfaces<C>;
    /**
     * Interface for creating maintenance transactions for the contract that was
     * deployed.
     */
    readonly contractMaintenanceTx: ContractMaintenanceTxInterface;
};
/**
 * Creates an instance of {@link FoundContract} given the address of a deployed contract and the
 * private address with an existing private state. The current value at the private address is used
 * as the `initialPrivateState` value in the `finalizedDeployTxData` property of the returned
 * `FoundContract`.
 *
 * @param providers The providers used to manage the transaction lifecycle.
 * @param options Configuration.
 *
 * @throws Error No contract state could be found at `contractAddress`.
 * @throws TypeError Thrown if `contractAddress` is not correctly formatted as a contract address.
 * @throws ContractTypeError One or more circuits defined on `contract` are undefined on the contract
 *                           state found at `contractAddress`, or have mis-matched verifier keys.
 */
export declare const findDeployedContract: <PSS extends PrivateStateSchema, PSK extends PrivateStateKey<PSS>, C extends Contract<PSS[PSK]>>(providers: MidnightProviders<ImpureCircuitId<C>, PSS>, { contract, contractAddress, privateStateKey, initialPrivateState, signingKey }: FindDeployedContractOptions<PSS, PSK, C>) => Promise<FoundContract<PSS[PSK], C>>;
//# sourceMappingURL=find-deployed-contract.d.ts.map