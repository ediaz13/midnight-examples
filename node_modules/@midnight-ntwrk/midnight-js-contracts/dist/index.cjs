'use strict';

var midnightJsTypes = require('@midnight-ntwrk/midnight-js-types');
var compactRuntime = require('@midnight-ntwrk/compact-runtime');
var midnightJsUtils = require('@midnight-ntwrk/midnight-js-utils');
var ledger = require('@midnight-ntwrk/ledger');
var midnightJsNetworkId = require('@midnight-ntwrk/midnight-js-network-id');

/**
 * Typesafe version of `Object.keys(contract.impureCircuits)`.
 *
 * @param contract The contract having impure circuits for which we want ids.
 *
 * @typeParam C The contract type for which we would like impure circuit IDs.
 */
const getImpureCircuitIds = (contract) => Object.keys(contract.impureCircuits);

/**
 * An error indicating that a transaction submitted to a consensus node failed.
 */
class TxFailedError extends Error {
    /**
     * @param finalizedTxData The finalization data of the transaction that failed.
     * @param circuitId The name of the circuit that was called to create the call
     *                  transaction that failed. Only defined if a call transaction
     *                  failed.
     */
    constructor(finalizedTxData, circuitId) {
        super('Transaction failed');
        this.finalizedTxData = finalizedTxData;
        this.circuitId = circuitId;
        this.message = JSON.stringify({
            ...(circuitId && { circuitId }),
            ...finalizedTxData
        }, null, '\t');
    }
}
/**
 * An error indicating that a deploy transaction was not successfully applied by the consensus node.
 */
class DeployTxFailedError extends TxFailedError {
    /**
     * @param finalizedTxData The finalization data of the deployment transaction that failed.
     */
    constructor(finalizedTxData) {
        super(finalizedTxData);
        this.name = 'DeployTxFailedError';
    }
}
/**
 * An error indicating that a call transaction was not successfully applied by the consensus node.
 */
class CallTxFailedError extends TxFailedError {
    /**
     * @param finalizedTxData The finalization data of the call transaction that failed.
     * @param circuitId The name of the circuit that was called to build the transaction.
     */
    constructor(finalizedTxData, circuitId) {
        super(finalizedTxData, circuitId);
        this.name = 'CallTxFailedError';
    }
}
/**
 * The error that is thrown when there is a contract type mismatch between a given contract type,
 * and the initial state that is deployed at a given contract address.
 *
 * @remarks
 * This error is typically thrown during calls to {@link findDeployedContract} where the supplied contract
 * address represents a different type of contract to the contract type given.
 */
class ContractTypeError extends TypeError {
    /**
     * Initializes a new {@link ContractTypeError}.
     *
     * @param contractState The initial deployed contract state.
     * @param circuitIds The circuits that are undefined, or have a verifier key mismatch with the
     *                   key present in `contractState`.
     */
    constructor(contractState, circuitIds) {
        super(`Following operations: ${circuitIds.join(', ')}, are undefined or have mismatched verifier keys for contract state ${contractState.toString(false)}`);
        this.contractState = contractState;
        this.circuitIds = circuitIds;
    }
}
/**
 * An error indicating that a contract maintenance authority replacement transaction failed.
 */
class ReplaceMaintenanceAuthorityTxFailedError extends TxFailedError {
    constructor(finalizedTxData) {
        super(finalizedTxData);
        this.name = 'ReplaceMaintenanceAuthorityTxFailedError';
    }
}
/**
 * An error indicating that a verifier key removal transaction failed.
 */
class RemoveVerifierKeyTxFailedError extends TxFailedError {
    constructor(finalizedTxData) {
        super(finalizedTxData);
        this.name = 'RemoveVerifierKeyTxFailedError';
    }
}
/**
 * An error indicating that a verifier key insertion transaction failed.
 */
class InsertVerifierKeyTxFailedError extends TxFailedError {
    constructor(finalizedTxData) {
        super(finalizedTxData);
        this.name = 'InsertVerifierKeyTxFailedError';
    }
}

/**
 * Retrieves the Zswap, ledger, and private states of the contract corresponding
 * to the given identifier using the given providers.
 *
 * @param publicDataProvider The provider to use to fetch the public states (Zswap and ledger).
 * @param privateStateProvider The provider to use to fetch the private state.
 * @param contractAddress The ledger address of the contract.
 * @param privateStateKey The identifier for the private state of the contract.
 */
const getStates = async (publicDataProvider, privateStateProvider, contractAddress, privateStateKey) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    const zswapAndContractState = await publicDataProvider.queryZSwapAndContractState(contractAddress);
    midnightJsUtils.assertDefined(zswapAndContractState, `No public state found at contract address '${contractAddress}'`);
    const [zswapChainState, contractState] = zswapAndContractState;
    const privateState = await privateStateProvider.get(privateStateKey);
    midnightJsUtils.assertDefined(privateState, `No private state found at private state key '${privateStateKey}'`);
    return { zswapChainState, contractState, privateState };
};

const checkKeys = (coinInfo) => Object.keys(coinInfo).forEach((key) => {
    if (key !== 'value' && key !== 'type' && key !== 'nonce') {
        throw new Error(`Key '${key}' should not be present in output data ${coinInfo}`);
    }
});
const serializeCoinInfo = (coinInfo) => {
    checkKeys(coinInfo);
    return JSON.stringify({
        ...coinInfo,
        value: { __big_int_val__: coinInfo.value.toString() }
    });
};
const serializeQualifiedCoinInfo = (coinInfo) => {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars, camelcase
    const { mt_index, ...rest } = coinInfo;
    return serializeCoinInfo(rest);
};
const deserializeCoinInfo = (coinInfo) => {
    const res = JSON.parse(coinInfo, (key, value) => {
        if (key === 'value' &&
            value != null &&
            typeof value === 'object' &&
            '__big_int_val__' in value &&
            // eslint-disable-next-line no-underscore-dangle
            typeof value.__big_int_val__ === 'string') {
            // eslint-disable-next-line no-underscore-dangle
            return BigInt(value.__big_int_val__);
        }
        if ((key === 'color' || key === 'nonce') &&
            value != null &&
            typeof value === 'object' &&
            '__uint8Array_val__' in value &&
            // eslint-disable-next-line no-underscore-dangle
            typeof value.__uint8Array_val__ === 'string') {
            // eslint-disable-next-line no-underscore-dangle
            return midnightJsUtils.fromHex(value.__uint8Array_val__);
        }
        return value;
    });
    checkKeys(res);
    return res;
};
const createUnprovenOutput = ({ coinInfo, recipient }) => recipient.is_left
    ? ledger.UnprovenOutput.new(coinInfo, recipient.left)
    : ledger.UnprovenOutput.newContractOwned(coinInfo, recipient.right);
const unprovenOfferFromCoinInfo = ([coinInfo, unproven], f) => {
    const { type, value } = deserializeCoinInfo(coinInfo);
    return f(unproven, type, value);
};
const unprovenOfferFromMap = (map, f) => Array.from(map)
    .map((coinInfo) => unprovenOfferFromCoinInfo(coinInfo, f))
    .reduce((acc, curr) => acc.merge(curr), new ledger.UnprovenOffer());
const zswapStateToOffer = (zswapLocalState, params) => {
    const unprovenOutputs = new Map(zswapLocalState.outputs.map((output) => [
        serializeCoinInfo(output.coinInfo),
        createUnprovenOutput(output)
    ]));
    const unprovenInputs = new Map();
    const unprovenTransients = new Map();
    zswapLocalState.inputs.forEach((qualifiedCoinInfo) => {
        const serializedCoinInfo = serializeQualifiedCoinInfo(qualifiedCoinInfo);
        const unprovenOutput = unprovenOutputs.get(serializedCoinInfo);
        if (unprovenOutput) {
            unprovenTransients.set(serializedCoinInfo, ledger.UnprovenTransient.newFromContractOwnedOutput(qualifiedCoinInfo, unprovenOutput));
            unprovenOutputs.delete(serializedCoinInfo);
        }
        else {
            midnightJsUtils.assertDefined(params, `Only outputs or transients are expected when no chain state is provided`);
            midnightJsUtils.assertIsContractAddress(params.contractAddress);
            unprovenInputs.set(serializedCoinInfo, ledger.UnprovenInput.newContractOwned(qualifiedCoinInfo, params.contractAddress, params.zswapChainState));
        }
    });
    return unprovenOfferFromMap(unprovenInputs, ledger.UnprovenOffer.fromInput)
        .merge(unprovenOfferFromMap(unprovenOutputs, ledger.UnprovenOffer.fromOutput))
        .merge(unprovenOfferFromMap(unprovenTransients, ledger.UnprovenOffer.fromTransient));
};
const zswapStateToNewCoins = (receiverCoinPublicKey, zswapState) => zswapState.outputs
    .filter((output) => output.recipient.left === receiverCoinPublicKey)
    .map(({ coinInfo }) => coinInfo);

const toLedgerContractState = (contractState) => ledger.ContractState.deserialize(contractState.serialize(midnightJsNetworkId.getRuntimeNetworkId()), midnightJsNetworkId.getLedgerNetworkId());
const fromLedgerContractState = (contractState) => compactRuntime.ContractState.deserialize(contractState.serialize(midnightJsNetworkId.getLedgerNetworkId()), midnightJsNetworkId.getRuntimeNetworkId());
const toLedgerQueryContext = (queryContext) => new ledger.QueryContext(ledger.StateValue.decode(queryContext.state.encode()), queryContext.address);
const addVerifierKeys = (verifierKeys, contractState) => {
    verifierKeys.forEach(([impureCircuitId, verifierKey]) => {
        const operation = contractState.operation(impureCircuitId);
        midnightJsUtils.assertDefined(operation, `Circuit '${impureCircuitId}' is undefined for contract state ${contractState.toString(false)}`);
        // TODO: Remove mutability
        operation.verifierKey = verifierKey;
        contractState.setOperation(impureCircuitId, operation);
    });
};
const contractMaintenanceAuthority = (sk, contractState) => {
    const svk = compactRuntime.signatureVerifyingKey(sk);
    const threshold = 1;
    return new ledger.ContractMaintenanceAuthority([svk], threshold, contractState ? contractState.maintenanceAuthority.counter + 1n : 0n);
};
const addMaintenanceAuthority = (sk, contractState) => {
    // eslint-disable-next-line no-param-reassign
    contractState.maintenanceAuthority = contractMaintenanceAuthority(sk);
};
const createUnprovenLedgerDeployTx = (verifierKeys, sk, contractState, zswapLocalState) => {
    const ledgerContractState = toLedgerContractState(contractState);
    addVerifierKeys(verifierKeys, ledgerContractState);
    addMaintenanceAuthority(sk, ledgerContractState);
    const contractDeploy = new ledger.ContractDeploy(ledgerContractState);
    return [
        contractDeploy.address,
        fromLedgerContractState(contractDeploy.initialState),
        new midnightJsTypes.UnprovenTransaction(zswapStateToOffer(zswapLocalState), undefined, new ledger.ContractCallsPrototype().addDeploy(contractDeploy))
    ];
};
const createUnprovenLedgerCallTx = (circuitId, contractAddress, initialContractState, zswapChainState, partitionedTranscript, privateTranscriptOutputs, input, output, nextZswapLocalState) => {
    const op = toLedgerContractState(initialContractState).operation(circuitId);
    midnightJsUtils.assertDefined(op, `Operation '${circuitId}' is undefined for contract state ${initialContractState.toString(false)}`);
    return new midnightJsTypes.UnprovenTransaction(zswapStateToOffer(nextZswapLocalState, {
        contractAddress,
        zswapChainState
    }), undefined, new ledger.ContractCallsPrototype().addCall(new ledger.ContractCallPrototype(contractAddress, circuitId, op, partitionedTranscript[0], partitionedTranscript[1], privateTranscriptOutputs, input, output, ledger.communicationCommitmentRandomness(), circuitId)));
};
// Utilities for creating single contract updates.
const replaceAuthority = (newAuthority, contractState) => new ledger.ReplaceAuthority(contractMaintenanceAuthority(newAuthority, contractState));
const removeVerifierKey = (operation) => new ledger.VerifierKeyRemove(operation, new ledger.ContractOperationVersion('v1'));
const insertVerifierKey = (operation, newVk) => new ledger.VerifierKeyInsert(operation, new ledger.ContractOperationVersionedVerifierKey('v1', newVk));
// Utilities for unproven transactions for the single contract updates above.
const unprovenTxFromContractUpdates = (contractAddress, updates, contractState, sk) => {
    const maintenanceUpdate = new ledger.MaintenanceUpdate(contractAddress, updates, contractState.maintenanceAuthority.counter);
    // 'idx' is '0n' because Midnight.js currently only supports single-party maintenance update authorities
    const idx = 0n;
    const signedMaintenanceUpdate = maintenanceUpdate.addSignature(idx, ledger.signData(sk, maintenanceUpdate.dataToSign));
    return new midnightJsTypes.UnprovenTransaction(new ledger.UnprovenOffer(), undefined, new ledger.ContractCallsPrototype().addMaintenanceUpdate(signedMaintenanceUpdate));
};
const createUnprovenReplaceAuthorityTx = (contractAddress, newAuthority, contractState, currentAuthority) => unprovenTxFromContractUpdates(contractAddress, [replaceAuthority(newAuthority, contractState)], contractState, currentAuthority);
const createUnprovenRemoveVerifierKeyTx = (contractAddress, operation, contractState, currentAuthority) => unprovenTxFromContractUpdates(contractAddress, [removeVerifierKey(operation)], contractState, currentAuthority);
const createUnprovenInsertVerifierKeyTx = (contractAddress, operation, newVk, contractState, currentAuthority) => unprovenTxFromContractUpdates(contractAddress, [insertVerifierKey(operation, newVk)], contractState, currentAuthority);

const partitionTranscript = (initialTxContext, finalTxContext, publicTranscript) => {
    const partitionedTranscripts = ledger.partitionTranscripts([
        new ledger.PreTranscript(Array.from(finalTxContext.comIndicies).reduce((queryContext, entry) => queryContext.insertCommitment(...entry), toLedgerQueryContext(initialTxContext)), publicTranscript)
    ], ledger.LedgerParameters.dummyParameters());
    if (partitionedTranscripts.length !== 1) {
        throw new Error(`Expected one transcript partition pair, received: ${partitionedTranscripts.length}`);
    }
    return partitionedTranscripts[0];
};
/**
 * Calls a circuit in the given contract according to the given configuration.
 *
 * @param options Configuration.
 */
const call = (options) => {
    const { contract, circuitId, contractAddress, initialContractState, initialPrivateState, coinPublicKey } = options;
    const circuit = contract.impureCircuits[circuitId];
    midnightJsUtils.assertDefined(circuit, `Circuit '${circuitId}' is not defined`);
    const initialTxContext = new compactRuntime.QueryContext(initialContractState.data, contractAddress);
    const { result, context, proofData } = circuit({
        originalState: initialContractState,
        currentPrivateState: initialPrivateState,
        transactionContext: initialTxContext,
        currentZswapLocalState: compactRuntime.emptyZswapLocalState(coinPublicKey)
    }, ...('args' in options ? options.args : []));
    return {
        public: {
            nextContractState: context.transactionContext.state,
            publicTranscript: proofData.publicTranscript,
            partitionedTranscript: partitionTranscript(initialTxContext, context.transactionContext, proofData.publicTranscript)
        },
        private: {
            result,
            input: proofData.input,
            output: proofData.output,
            privateTranscriptOutputs: proofData.privateTranscriptOutputs,
            nextPrivateState: context.currentPrivateState,
            nextZswapLocalState: compactRuntime.decodeZswapLocalState(context.currentZswapLocalState)
        }
    };
};

/**
 * Calls a circuit using the provided initial `states` and creates an unbalanced,
 * unproven, unsubmitted, call transaction.
 *
 * @param initialZswapChainState The contract's initial Zswap chain state.
 * @param options Configuration.
 *
 * @returns A promise that contains all data produced by the circuit call and an unproven
 *          transaction assembled from the call result.
 */
const createUnprovenCallTxFromInitialStates = async (initialZswapChainState, options) => {
    const { contract, circuitId, contractAddress, initialContractState, coinPublicKey } = options;
    midnightJsUtils.assertIsContractAddress(contractAddress);
    midnightJsUtils.assertDefined(contract.impureCircuits[circuitId], `Circuit '${circuitId}' is undefined`);
    const callResult = call(options);
    return {
        public: {
            ...callResult.public
        },
        private: {
            ...callResult.private,
            unprovenTx: createUnprovenLedgerCallTx(circuitId, contractAddress, initialContractState, initialZswapChainState, callResult.public.partitionedTranscript, callResult.private.privateTranscriptOutputs, callResult.private.input, callResult.private.output, callResult.private.nextZswapLocalState),
            newCoins: zswapStateToNewCoins(coinPublicKey, callResult.private.nextZswapLocalState)
        }
    };
};
/**
 * Calls a circuit using states fetched from the public data provider and private state
 * provider, then creates an unbalanced, unproven, unsubmitted, call transaction.
 *
 * @param publicDataProvider The provider to use to fetch the contract ledger and Zswap chain states.
 * @param privateStateProvider The provider to use to fetch the contract private state.
 * @param walletProvider The provider to use to fetch the current user's Zswap coin public key.
 * @param options Configuration.
 *
 * @returns A promise that contains all data produced by the circuit call and an unproven
 *          transaction assembled from the call result.
 */
const createUnprovenCallTx = async (publicDataProvider, privateStateProvider, walletProvider, options) => {
    const { contract, circuitId, contractAddress, privateStateKey } = options;
    midnightJsUtils.assertIsContractAddress(contractAddress);
    midnightJsUtils.assertDefined(contract.impureCircuits[circuitId], `Circuit '${circuitId}' is undefined`);
    const { zswapChainState, contractState, privateState } = await getStates(publicDataProvider, privateStateProvider, contractAddress, privateStateKey);
    return createUnprovenCallTxFromInitialStates(zswapChainState, {
        ...options,
        initialPrivateState: privateState,
        initialContractState: contractState,
        coinPublicKey: walletProvider.coinPublicKey
    });
};

/**
 * Proves, balances, and submits an unproven deployment or call transaction using
 * the given providers, according to the given options.
 *
 * @param providers The providers used to manage the transaction lifecycle.
 * @param options Configuration.
 *
 * @returns A promise that resolves with the finalized transaction data for the invocation,
 *          or rejects if an error occurs along the way.
 */
const submitTx = async (providers, options) => {
    const proveTxConfig = options.circuitId
        ? { zkConfig: await providers.zkConfigProvider.get(options.circuitId) }
        : undefined;
    const unbalancedTx = await providers.proofProvider.proveTx(options.unprovenTx, proveTxConfig);
    const balancedTx = await providers.walletProvider.balanceTx(unbalancedTx, options.newCoins ?? []);
    const txId = await providers.midnightProvider.submitTx(balancedTx);
    const finalizedTxData = await providers.publicDataProvider.watchForTxData(txId);
    return finalizedTxData;
};

/**
 * Creates and submits a transaction for the invocation of a circuit on a given contract.
 *
 * @param providers The providers used to manage the invocation lifecycle.
 * @param options Configuration.
 *
 * @returns A `Promise` that resolves with the finalized transaction data for the invocation of
 *         `circuitId` on `contract` with the given `args`; or rejects with an error if the invocation fails.
 */
const submitCallTx = async (providers, options) => {
    const unprovenCallTxData = await createUnprovenCallTx(providers.publicDataProvider, providers.privateStateProvider, providers.walletProvider, options);
    const finalizedTxData = await submitTx(providers, {
        unprovenTx: unprovenCallTxData.private.unprovenTx,
        newCoins: unprovenCallTxData.private.newCoins,
        circuitId: options.circuitId
    });
    if (finalizedTxData.status !== midnightJsTypes.SucceedEntirely) {
        throw new CallTxFailedError(finalizedTxData, options.circuitId);
    }
    // TODO: What if machine crashes right before the following set executes? How to recover?
    //       Likely will need a history of pending transactions.
    await providers.privateStateProvider.set(options.privateStateKey, unprovenCallTxData.private.nextPrivateState);
    return {
        private: {
            ...unprovenCallTxData.private
        },
        public: {
            ...unprovenCallTxData.public,
            ...finalizedTxData
        }
    };
};

/**
 * Constructs and submits a transaction that replaces the maintenance
 * authority stored on the blockchain for this contract. After the transaction is
 * finalized, the current signing key stored in the given private state provider
 * is overwritten with the given new authority key.
 *
 * @param providers The providers to use to manage the transaction lifecycle.
 * @param privateStateKey THe key at which the contract being update has its state stored.
 * @param contractAddress The address of the contract for which the maintenance
 *                        authority should be updated.
 *
 * TODO: There are at least three options we should support in the future:
 *       1. Replace authority and maintain key (current).
 *       2. Replace authority and do not maintain key.
 *       3. Add additional authorities and maintain original key.
 */
const submitReplaceAuthorityTx = (providers, privateStateKey, contractAddress) => 
/**
 * @param newAuthority The signing key of the new contract maintenance authority.
 *
 * @returns A promise that resolves with the finalized transaction data, or rejects if
 *          an error occurs along the way.
 */
async (newAuthority) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    const contractState = await providers.publicDataProvider.queryContractState(contractAddress);
    midnightJsUtils.assertDefined(contractState, `No contract state found on chain for contract address '${contractAddress}'`);
    const currentAuthority = await providers.privateStateProvider.getSigningKey(privateStateKey);
    midnightJsUtils.assertDefined(currentAuthority, `Signing key for private state key '${privateStateKey}' not found`);
    const unprovenTx = createUnprovenReplaceAuthorityTx(contractAddress, newAuthority, contractState, currentAuthority);
    const submitTxResult = await submitTx(providers, { unprovenTx });
    if (submitTxResult.status !== midnightJsTypes.SucceedEntirely) {
        throw new ReplaceMaintenanceAuthorityTxFailedError(submitTxResult);
    }
    // TODO: What if machine crashes right before the following set executes? How to recover?
    //       Likely will need a history of pending transactions.
    await providers.privateStateProvider.setSigningKey(privateStateKey, newAuthority);
    return submitTxResult;
};

/**
 * Constructs and submits a transaction that adds a new verifier key to the
 * blockchain for the given circuit ID at the given contract address.
 *
 * @param providers The providers to use to manage the transaction lifecycle.
 * @param privateStateKey The private state key for the contract.
 * @param contractAddress The address of the contract containing the circuit for which
 *                        the verifier key should be inserted.
 * @param circuitId The circuit for which the verifier key should be inserted.
 * @param newVk The new verifier key for the circuit.
 *
 * @returns A promise that resolves with the finalized transaction data, or rejects if
 *          an error occurs along the way.
 *
 * TODO: We'll likely want to modify ZKConfigProvider provider so that the verifier keys are
 *       automatically rotated in this function. This likely involves storing key versions
 *       along with keys in ZKConfigProvider. By default, artifacts for the latest version
 *       would be fetched to build transactions.
 */
const submitInsertVerifierKeyTx = async (providers, privateStateKey, contractAddress, circuitId, newVk) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    const contractState = await providers.publicDataProvider.queryContractState(contractAddress);
    midnightJsUtils.assertDefined(contractState, `No contract state found on chain for contract address '${contractAddress}'`);
    midnightJsUtils.assertUndefined(contractState.operation(circuitId), `Circuit '${circuitId}' is already defined for contract at address '${contractAddress}'`);
    const signingKey = await providers.privateStateProvider.getSigningKey(privateStateKey);
    midnightJsUtils.assertDefined(signingKey, `Signing key for private state key '${privateStateKey}' not found`);
    const unprovenTx = createUnprovenInsertVerifierKeyTx(contractAddress, circuitId, newVk, contractState, signingKey);
    const submitTxResult = await submitTx(providers, { unprovenTx });
    if (submitTxResult.status !== midnightJsTypes.SucceedEntirely) {
        throw new InsertVerifierKeyTxFailedError(submitTxResult);
    }
    return submitTxResult;
};

/**
 * Constructs and submits a transaction that removes the current verifier key stored
 * on the blockchain for the given circuit ID at the given contract address.
 *
 * @param providers The providers to use to manage the transaction lifecycle.
 * @param privateStateKey The private state key for the contract.
 * @param contractAddress The address of the contract containing the circuit for which
 *                        the verifier key should be removed.
 * @param circuitId The circuit for which the verifier key should be removed.
 *
 * @returns A promise that resolves with the finalized transaction data, or rejects if
 *          an error occurs along the way.
 *
 * TODO: We'll likely want to modify ZKConfigProvider provider so that the verifier keys are
 *       automatically rotated in this function. This likely involves storing key versions
 *       along with keys in ZKConfigProvider. By default, artifacts for the latest version
 *       would be fetched to build transactions.
 */
const submitRemoveVerifierKeyTx = async (providers, privateStateKey, contractAddress, circuitId) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    const contractState = await providers.publicDataProvider.queryContractState(contractAddress);
    midnightJsUtils.assertDefined(contractState, `No contract state found on chain for contract address '${contractAddress}'`);
    midnightJsUtils.assertDefined(contractState.operation(circuitId), `Circuit '${circuitId}' not found for contract at address '${contractAddress}'`);
    const signingKey = await providers.privateStateProvider.getSigningKey(privateStateKey);
    midnightJsUtils.assertDefined(signingKey, `Signing key for private state key '${privateStateKey}' not found`);
    const unprovenTx = createUnprovenRemoveVerifierKeyTx(contractAddress, circuitId, contractState, signingKey);
    const submitTxResult = await submitTx(providers, { unprovenTx });
    if (submitTxResult.status !== midnightJsTypes.SucceedEntirely) {
        throw new RemoveVerifierKeyTxFailedError(submitTxResult);
    }
    return submitTxResult;
};

/**
 * Creates a {@link CallTxOptions} object from various data.
 */
const createCallTxOptions = (contract, circuitId, contractAddress, privateStateKey, args) => {
    const callOptionsBase = {
        contract,
        circuitId,
        contractAddress,
        privateStateKey
    };
    return (args.length !== 0
        ? {
            ...callOptionsBase,
            args
        }
        : callOptionsBase);
};
/**
 * Creates a circuit call transaction interface for a contract.
 *
 * @param providers The providers to use to build transactions.
 * @param contract The contract to use to execute circuits.
 * @param contractAddress The ledger address of the contract.
 * @param privateStateKey The address of the state of the witnesses of the contract.
 */
const createCircuitCallTxInterface = (providers, contract, contractAddress, privateStateKey) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    return getImpureCircuitIds(contract).reduce((acc, circuitId) => ({
        ...acc,
        [circuitId]: (...args) => submitCallTx(providers, createCallTxOptions(contract, circuitId, contractAddress, privateStateKey, args))
    }), {});
};
/**
 * Creates a {@link CircuitMaintenanceTxInterface}.
 *
 * @param providers The providers to use to create and submit transactions.
 * @param circuitId The circuit ID the interface is for.
 * @param privateStateKey The private state key for the contract.
 * @param contractAddress The address of the deployed contract for which this
 *                        interface is being created.
 */
const createCircuitMaintenanceTxInterface = (providers, circuitId, privateStateKey, contractAddress) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    return {
        removeVerifierKey() {
            return submitRemoveVerifierKeyTx(providers, privateStateKey, contractAddress, circuitId);
        },
        insertVerifierKey(newVk) {
            return submitInsertVerifierKeyTx(providers, privateStateKey, contractAddress, circuitId, newVk);
        }
    };
};
/**
 * Creates a {@link CircuitMaintenanceTxInterfaces}.
 *
 * @param providers The providers to use to build transactions.
 * @param contract The contract to use to execute circuits.
 * @param privateStateKey The private state key for the contract.
 * @param contractAddress The ledger address of the contract.
 */
const createCircuitMaintenanceTxInterfaces = (providers, contract, privateStateKey, contractAddress) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    return getImpureCircuitIds(contract).reduce((acc, circuitId) => ({
        ...acc,
        [circuitId]: createCircuitMaintenanceTxInterface(providers, circuitId, privateStateKey, contractAddress)
    }), {});
};
/**
 * Creates a {@link ContractMaintenanceTxInterface}.
 *
 * @param providers The providers to use to build transactions.
 * @param privateStateKey The private state key for the contract.
 * @param contractAddress The ledger address of the contract.
 */
const createContractMaintenanceTxInterface = (providers, privateStateKey, contractAddress) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    return {
        replaceAuthority: submitReplaceAuthorityTx(providers, privateStateKey, contractAddress)
    };
};

/**
 * Calls a contract constructor and creates an unbalanced, unproven, unsubmitted, deploy transaction
 * from the constructor results.
 *
 * @param verifierKeys The verifier keys for the contract being deployed.
 * @param coinPublicKey The Zswap coin public key of the current user.
 * @param options Configuration.
 *
 * @returns A promise that contains all data produced by the contract constructor call and an unproven
 *          deployment transaction assembled from the contract constructor result.
 */
const createUnprovenDeployTxFromVerifierKeys = async (verifierKeys, coinPublicKey, options) => {
    const { currentContractState, currentPrivateState, currentZswapLocalState } = options.contract.initialState(compactRuntime.constructorContext(options.initialPrivateState, coinPublicKey), ...('args' in options ? options.args : []));
    const decodedCurrentZswapLocalState = compactRuntime.decodeZswapLocalState(currentZswapLocalState);
    const [contractAddress, initialContractState, unprovenTx] = createUnprovenLedgerDeployTx(verifierKeys, options.signingKey, currentContractState, decodedCurrentZswapLocalState);
    return {
        public: {
            contractAddress,
            initialContractState
        },
        private: {
            signingKey: options.signingKey,
            initialPrivateState: currentPrivateState,
            initialZswapState: decodedCurrentZswapLocalState,
            unprovenTx,
            newCoins: zswapStateToNewCoins(coinPublicKey, decodedCurrentZswapLocalState)
        }
    };
};
/**
 * Calls a contract constructor and creates an unbalanced, unproven, unsubmitted, deploy transaction
 * from the constructor results.
 *
 * @param zkConfigProvider The provider to use to fetch ZK artifacts.
 * @param walletProvider The provider to use to get the current user's Zswap coin public key.
 * @param options Configuration.
 *
 * @returns A promise that contains all data produced by the constructor call and an unproven
 *          transaction assembled from the constructor result.
 */
const createUnprovenDeployTx = async (zkConfigProvider, walletProvider, options) => {
    const verifierKeys = await zkConfigProvider.getVerifierKeys(getImpureCircuitIds(options.contract));
    return createUnprovenDeployTxFromVerifierKeys(verifierKeys, walletProvider.coinPublicKey, options);
};

/**
 * Creates and submits a contract deployment transaction. This function is the entry point for the transaction
 * construction workflow and is used to create a {@link DeployedContract} instance.
 *
 * @param providers The providers used to manage the transaction lifecycle.
 * @param options Configuration.
 *
 * @throws DeployTxFailedError If the transaction is submitted successfully but produces an error
 *                        when executed by the node.
 */
const deployContract = async (providers, options) => {
    const unprovenDeployTxData = await createUnprovenDeployTx(providers.zkConfigProvider, providers.walletProvider, {
        ...options,
        signingKey: options.signingKey ?? compactRuntime.sampleSigningKey()
    });
    const finalizedTxData = await submitTx(providers, {
        unprovenTx: unprovenDeployTxData.private.unprovenTx,
        newCoins: unprovenDeployTxData.private.newCoins
    });
    if (finalizedTxData.status !== midnightJsTypes.SucceedEntirely) {
        throw new DeployTxFailedError(finalizedTxData);
    }
    await providers.privateStateProvider.set(options.privateStateKey, unprovenDeployTxData.private.initialPrivateState);
    await providers.privateStateProvider.setSigningKey(options.privateStateKey, unprovenDeployTxData.private.signingKey);
    return {
        deployTxData: {
            private: {
                ...unprovenDeployTxData.private
            },
            public: {
                ...finalizedTxData,
                ...unprovenDeployTxData.public
            }
        },
        callTx: createCircuitCallTxInterface(providers, options.contract, unprovenDeployTxData.public.contractAddress, options.privateStateKey),
        circuitMaintenanceTx: createCircuitMaintenanceTxInterfaces(providers, options.contract, options.privateStateKey, unprovenDeployTxData.public.contractAddress),
        contractMaintenanceTx: createContractMaintenanceTxInterface(providers, options.privateStateKey, unprovenDeployTxData.public.contractAddress)
    };
};

const setInitialSigningKey = async (privateStateProvider, privateStateKey, signingKey) => {
    if (signingKey !== undefined) {
        await privateStateProvider.setSigningKey(privateStateKey, signingKey);
        return signingKey;
    }
    const existingSigningKey = await privateStateProvider.getSigningKey(privateStateKey);
    if (existingSigningKey) {
        return existingSigningKey;
    }
    const freshSigningKey = compactRuntime.sampleSigningKey();
    await privateStateProvider.setSigningKey(privateStateKey, freshSigningKey);
    return freshSigningKey;
};
const setInitialPrivateState = async (privateStateProvider, privateStateKey, initialPrivateState) => {
    if (initialPrivateState !== undefined) {
        await privateStateProvider.set(privateStateKey, initialPrivateState);
        return initialPrivateState;
    }
    const existingPrivateState = await privateStateProvider.get(privateStateKey);
    midnightJsUtils.assertDefined(existingPrivateState, `No existing private state found for private state key '${privateStateKey}'`);
    return existingPrivateState;
};
/**
 * Checks that two verifier keys are equal. Does initial length check match for efficiency.
 *
 * @param a First verifier key.
 * @param b Second verifier key.
 */
const verifierKeysEqual = (a, b) => a.length === b.length && midnightJsUtils.toHex(a) === midnightJsUtils.toHex(b);
/**
 * Checks that the given `contractState` contains the given `verifierKeys`.
 *
 * @param verifierKeys The verifier keys the client has for the deployed contract we're checking.
 * @param contractState The (typically already deployed) contract state containing verifier keys.
 *
 * @throws ContractTypeError When one or more of the local and deployed verifier keys do not match.
 */
const verifyContractState = (verifierKeys, contractState) => {
    const mismatchedCircuitIds = verifierKeys.reduce((acc, [circuitId, localVk]) => !contractState.operation(circuitId) ||
        !verifierKeysEqual(localVk, contractState.operation(circuitId).verifierKey)
        ? [...acc, circuitId]
        : acc, []);
    if (mismatchedCircuitIds.length > 0) {
        throw new ContractTypeError(contractState, mismatchedCircuitIds);
    }
};
/**
 * Creates an instance of {@link FoundContract} given the address of a deployed contract and the
 * private address with an existing private state. The current value at the private address is used
 * as the `initialPrivateState` value in the `finalizedDeployTxData` property of the returned
 * `FoundContract`.
 *
 * @param providers The providers used to manage the transaction lifecycle.
 * @param options Configuration.
 *
 * @throws Error No contract state could be found at `contractAddress`.
 * @throws TypeError Thrown if `contractAddress` is not correctly formatted as a contract address.
 * @throws ContractTypeError One or more circuits defined on `contract` are undefined on the contract
 *                           state found at `contractAddress`, or have mis-matched verifier keys.
 */
const findDeployedContract = async (providers, { contract, contractAddress, privateStateKey, initialPrivateState, signingKey }) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    const finalizedTxData = await providers.publicDataProvider.watchForDeployTxData(contractAddress);
    const initialContractState = await providers.publicDataProvider.queryDeployContractState(contractAddress);
    midnightJsUtils.assertDefined(initialContractState, `No contract deployed at contract address '${contractAddress}'`);
    const currentContractState = await providers.publicDataProvider.queryContractState(contractAddress);
    midnightJsUtils.assertDefined(currentContractState, `No contract deployed at contract address '${contractAddress}'`);
    const verifierKeys = await providers.zkConfigProvider.getVerifierKeys(getImpureCircuitIds(contract));
    verifyContractState(verifierKeys, currentContractState);
    return {
        deployTxData: {
            private: {
                signingKey: await setInitialSigningKey(providers.privateStateProvider, privateStateKey, signingKey),
                initialPrivateState: await setInitialPrivateState(providers.privateStateProvider, privateStateKey, initialPrivateState)
            },
            public: {
                ...finalizedTxData,
                contractAddress,
                initialContractState
            }
        },
        callTx: createCircuitCallTxInterface(providers, contract, contractAddress, privateStateKey),
        circuitMaintenanceTx: createCircuitMaintenanceTxInterfaces(providers, contract, privateStateKey, contractAddress),
        contractMaintenanceTx: createContractMaintenanceTxInterface(providers, privateStateKey, contractAddress)
    };
};

exports.CallTxFailedError = CallTxFailedError;
exports.ContractTypeError = ContractTypeError;
exports.DeployTxFailedError = DeployTxFailedError;
exports.InsertVerifierKeyTxFailedError = InsertVerifierKeyTxFailedError;
exports.RemoveVerifierKeyTxFailedError = RemoveVerifierKeyTxFailedError;
exports.ReplaceMaintenanceAuthorityTxFailedError = ReplaceMaintenanceAuthorityTxFailedError;
exports.TxFailedError = TxFailedError;
exports.call = call;
exports.createCallTxOptions = createCallTxOptions;
exports.createCircuitCallTxInterface = createCircuitCallTxInterface;
exports.createCircuitMaintenanceTxInterface = createCircuitMaintenanceTxInterface;
exports.createCircuitMaintenanceTxInterfaces = createCircuitMaintenanceTxInterfaces;
exports.createContractMaintenanceTxInterface = createContractMaintenanceTxInterface;
exports.createUnprovenCallTx = createUnprovenCallTx;
exports.createUnprovenCallTxFromInitialStates = createUnprovenCallTxFromInitialStates;
exports.createUnprovenDeployTx = createUnprovenDeployTx;
exports.createUnprovenDeployTxFromVerifierKeys = createUnprovenDeployTxFromVerifierKeys;
exports.deployContract = deployContract;
exports.findDeployedContract = findDeployedContract;
exports.getImpureCircuitIds = getImpureCircuitIds;
exports.getStates = getStates;
exports.submitCallTx = submitCallTx;
exports.submitInsertVerifierKeyTx = submitInsertVerifierKeyTx;
exports.submitRemoveVerifierKeyTx = submitRemoveVerifierKeyTx;
exports.submitReplaceAuthorityTx = submitReplaceAuthorityTx;
exports.submitTx = submitTx;
exports.verifierKeysEqual = verifierKeysEqual;
exports.verifyContractState = verifyContractState;
//# sourceMappingURL=index.cjs.map
