import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<T extends {
    [key: string]: unknown;
}, K extends keyof T> = {
    [_ in K]?: never;
};
export type Incremental<T> = T | {
    [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
    ID: {
        input: string;
        output: string;
    };
    String: {
        input: string;
        output: string;
    };
    Boolean: {
        input: boolean;
        output: boolean;
    };
    Int: {
        input: number;
        output: number;
    };
    Float: {
        input: number;
        output: number;
    };
    BigInt: {
        input: number;
        output: number;
    };
    /** An instantaneous point on the time-line represented by a standard date time string */
    Instant: {
        input: number;
        output: number;
    };
    SessionId: {
        input: string;
        output: string;
    };
    Unit: {
        input: null;
        output: null;
    };
};
export type Block = {
    hash: Scalars['String']['output'];
    height: Scalars['BigInt']['output'];
    parent: Maybe<Block>;
    timestamp: Scalars['Instant']['output'];
    transactions: Array<Transaction>;
};
export type BlockOffsetInput = {
    hash: InputMaybe<Scalars['String']['input']>;
    height: InputMaybe<Scalars['BigInt']['input']>;
};
export type ContractCall = ContractCallOrDeploy & {
    address: Scalars['String']['output'];
    deploy: ContractDeploy;
    operation: Scalars['String']['output'];
    state: Scalars['String']['output'];
    transaction: Transaction;
    zswapChainState: Scalars['String']['output'];
};
export type ContractCallOrDeploy = {
    address: Scalars['String']['output'];
    state: Scalars['String']['output'];
    transaction: Transaction;
    zswapChainState: Scalars['String']['output'];
};
export type ContractDeploy = ContractCallOrDeploy & {
    address: Scalars['String']['output'];
    definition: Scalars['String']['output'];
    state: Scalars['String']['output'];
    transaction: Transaction;
    zswapChainState: Scalars['String']['output'];
};
export type MerkleTreeCollapsedUpdate = {
    update: Scalars['String']['output'];
};
export type Mutation = {
    connect: Scalars['SessionId']['output'];
    disconnect: Scalars['Unit']['output'];
};
export type MutationConnectArgs = {
    viewingKey: Scalars['String']['input'];
};
export type MutationDisconnectArgs = {
    sessionId: Scalars['SessionId']['input'];
};
export type ProgressUpdate = {
    synced: Scalars['BigInt']['output'];
    total: Scalars['BigInt']['output'];
};
export type Query = {
    block: Maybe<Block>;
    contract: Maybe<ContractCallOrDeploy>;
    transactions: Array<Transaction>;
};
export type QueryBlockArgs = {
    offset: InputMaybe<BlockOffsetInput>;
};
export type QueryContractArgs = {
    address: Scalars['String']['input'];
    offset: InputMaybe<BlockOffsetInput>;
};
export type QueryTransactionsArgs = {
    hash: InputMaybe<Scalars['String']['input']>;
    identifier: InputMaybe<Scalars['String']['input']>;
};
export type RelevantTransaction = {
    transaction: Transaction;
};
export type Subscription = {
    blocks: Maybe<Block>;
    contract: Maybe<ContractCallOrDeploy>;
    transactions: Maybe<TransactionSyncEvent>;
    wallet: Maybe<WalletSyncEvent>;
};
export type SubscriptionBlocksArgs = {
    offset: InputMaybe<BlockOffsetInput>;
};
export type SubscriptionContractArgs = {
    address: Scalars['String']['input'];
    offset: InputMaybe<BlockOffsetInput>;
};
export type SubscriptionTransactionsArgs = {
    offset: InputMaybe<TransactionOffsetInput>;
};
export type SubscriptionWalletArgs = {
    blockHeight: InputMaybe<Scalars['BigInt']['input']>;
    sessionId: InputMaybe<Scalars['SessionId']['input']>;
};
export type Transaction = {
    applyStage: Scalars['String']['output'];
    block: Block;
    contractCalls: Array<ContractCallOrDeploy>;
    hash: Scalars['String']['output'];
    identifiers: Array<Scalars['String']['output']>;
    raw: Scalars['String']['output'];
};
export type TransactionAdded = {
    transaction: Transaction;
};
export type TransactionOffsetInput = {
    hash: InputMaybe<Scalars['String']['input']>;
    identifier: InputMaybe<Scalars['String']['input']>;
};
export type TransactionSyncEvent = ProgressUpdate | TransactionAdded;
export type ViewingUpdate = {
    blockHeight: Scalars['BigInt']['output'];
    update: Array<ZswapChainStateUpdate>;
};
export type WalletSyncEvent = ProgressUpdate | ViewingUpdate;
export type ZswapChainStateUpdate = MerkleTreeCollapsedUpdate | RelevantTransaction;
export type BlockHashQueryQueryVariables = Exact<{
    offset: InputMaybe<BlockOffsetInput>;
}>;
export type BlockHashQueryQuery = {
    block: {
        height: number;
        hash: string;
    } | null;
};
export type TxIdQueryQueryVariables = Exact<{
    identifier: Scalars['String']['input'];
}>;
export type TxIdQueryQuery = {
    transactions: Array<{
        raw: string;
        applyStage: string;
        hash: string;
        block: {
            height: number;
            hash: string;
        };
    }>;
};
export type DeployTxQueryQueryVariables = Exact<{
    address: Scalars['String']['input'];
}>;
export type DeployTxQueryQuery = {
    contract: {
        deploy: {
            transaction: {
                raw: string;
                applyStage: string;
                hash: string;
                identifiers: Array<string>;
                contractCalls: Array<{
                    address: string;
                }>;
                block: {
                    height: number;
                    hash: string;
                };
            };
        };
    } | {
        transaction: {
            raw: string;
            applyStage: string;
            hash: string;
            identifiers: Array<string>;
            contractCalls: Array<{
                address: string;
            }>;
            block: {
                height: number;
                hash: string;
            };
        };
    } | null;
};
export type DeployContractStateTxQueryQueryVariables = Exact<{
    address: Scalars['String']['input'];
}>;
export type DeployContractStateTxQueryQuery = {
    contract: {
        deploy: {
            transaction: {
                contractCalls: Array<{
                    address: string;
                    state: string;
                }>;
            };
        };
    } | {
        state: string;
    } | null;
};
export type LatestContractTxBlockHeightQueryQueryVariables = Exact<{
    address: Scalars['String']['input'];
}>;
export type LatestContractTxBlockHeightQueryQuery = {
    contract: {
        transaction: {
            block: {
                height: number;
            };
        };
    } | null;
};
export type TxsFromBlockSubSubscriptionVariables = Exact<{
    offset: InputMaybe<BlockOffsetInput>;
}>;
export type TxsFromBlockSubSubscription = {
    blocks: {
        hash: string;
        height: number;
        transactions: Array<{
            hash: string;
            identifiers: Array<string>;
            contractCalls: Array<{
                state: string;
                address: string;
            }>;
        }>;
    } | null;
};
export type ContractStateQueryQueryVariables = Exact<{
    address: Scalars['String']['input'];
    offset: InputMaybe<BlockOffsetInput>;
}>;
export type ContractStateQueryQuery = {
    contract: {
        state: string;
    } | null;
};
export type ContractStateSubSubscriptionVariables = Exact<{
    address: Scalars['String']['input'];
    offset: InputMaybe<BlockOffsetInput>;
}>;
export type ContractStateSubSubscription = {
    contract: {
        state: string;
    } | null;
};
export type BothStateQueryQueryVariables = Exact<{
    address: Scalars['String']['input'];
    offset: InputMaybe<BlockOffsetInput>;
}>;
export type BothStateQueryQuery = {
    contract: {
        state: string;
        zswapChainState: string;
    } | null;
};
export declare const BlockHashQueryDocument: DocumentNode<BlockHashQueryQuery, BlockHashQueryQueryVariables>;
export declare const TxIdQueryDocument: DocumentNode<TxIdQueryQuery, TxIdQueryQueryVariables>;
export declare const DeployTxQueryDocument: DocumentNode<DeployTxQueryQuery, DeployTxQueryQueryVariables>;
export declare const DeployContractStateTxQueryDocument: DocumentNode<DeployContractStateTxQueryQuery, DeployContractStateTxQueryQueryVariables>;
export declare const LatestContractTxBlockHeightQueryDocument: DocumentNode<LatestContractTxBlockHeightQueryQuery, LatestContractTxBlockHeightQueryQueryVariables>;
export declare const TxsFromBlockSubDocument: DocumentNode<TxsFromBlockSubSubscription, TxsFromBlockSubSubscriptionVariables>;
export declare const ContractStateQueryDocument: DocumentNode<ContractStateQueryQuery, ContractStateQueryQueryVariables>;
export declare const ContractStateSubDocument: DocumentNode<ContractStateSubSubscription, ContractStateSubSubscriptionVariables>;
export declare const BothStateQueryDocument: DocumentNode<BothStateQueryQuery, BothStateQueryQueryVariables>;
//# sourceMappingURL=graphql.d.ts.map