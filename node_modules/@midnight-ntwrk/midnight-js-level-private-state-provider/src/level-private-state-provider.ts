import type {
  PrivateStateProvider,
  PrivateStateSchema,
  PrivateStateKey
} from '@midnight-ntwrk/midnight-js-types';
import type { AbstractSublevel } from 'abstract-level';
import { Buffer } from 'buffer';
import { Level } from 'level';
import _ from 'lodash';
import * as io from 'io-ts';
import * as superjson from 'superjson';
import type { SigningKey } from '@midnight-ntwrk/compact-runtime';

/**
 * The default name of the indexedDB database for Midnight.
 */
export const MN_LDB_DEFAULT_DB_NAME = 'midnight-level-db';

/**
 * The default name of the private state store.
 */
export const MN_LDB_DEFAULT_PRIS_STORE_NAME = 'private-states';

/**
 * The default name of the signing key store.
 */
export const MN_LDB_DEFAULT_KEY_STORE_NAME = 'signing-keys';

/**
 * Optional properties for the indexedDB based private state provider configuration.
 */
export interface LevelPrivateStateProviderConfig {
  /**
   * The name of the LevelDB database used to store all Midnight related data.
   */
  readonly midnightDbName: string;
  /**
   * The name of the object store containing private states.
   */
  readonly privateStateStoreName: string;
  /**
   * The name of the object store containing signing keys.
   */
  readonly signingKeyStoreName: string;
}

/**
 * The default configuration for the level database.
 */
export const DEFAULT_CONFIG = {
  /**
   * The name of the database.
   */
  midnightDbName: MN_LDB_DEFAULT_DB_NAME,
  /**
   * The name of the "level" on which to store private state.
   */
  privateStateStoreName: MN_LDB_DEFAULT_PRIS_STORE_NAME,
  /**
   * The name of the "level" on which to store signing keys.
   */
  signingKeyStoreName: MN_LDB_DEFAULT_KEY_STORE_NAME
};

const LevelNotFoundError = io.type({
  code: io.literal('LEVEL_NOT_FOUND'),
  notFound: io.literal(true),
  status: io.literal(404)
});

superjson.registerCustom<Buffer, string>(
  {
    isApplicable: (v): v is Buffer => v instanceof Buffer,
    serialize: (v) => v.toString('hex'),
    deserialize: (v) => Buffer.from(v, 'hex')
  },
  'buffer'
);

const withSubLevel = async <K, V, A>(
  dbName: string,
  levelName: string,
  thunk: (subLevel: AbstractSublevel<Level, string | Uint8Array | Buffer, K, V>) => Promise<A>
): Promise<A> => {
  const level = new Level(dbName, {
    createIfMissing: true
  });
  const subLevel = level.sublevel<K, V>(levelName, {
    valueEncoding: {
      encode: superjson.stringify,
      decode: superjson.parse,
      name: 'super-json-values'
    }
  });
  try {
    await level.open();
    await subLevel.open();
    return await thunk(subLevel);
  } finally {
    await subLevel.close();
    await level.close();
  }
};

const subLevelMaybeGet = async <K, V>(
  dbName: string,
  levelName: string,
  key: K
): Promise<V | null> => {
  try {
    return await withSubLevel<K, V, V | null>(dbName, levelName, (subLevel) => subLevel.get(key));
  } catch (e) {
    if (LevelNotFoundError.is(e)) {
      return null;
    }
    throw e;
  }
};

/**
 * Constructs an instance of {@link PrivateStateProvider} based on {@link Level} database.
 * @param partialConfig Database configuration options.
 */
export const levelPrivateStateProvider = <PSS extends PrivateStateSchema>(
  partialConfig: Partial<LevelPrivateStateProviderConfig> = {}
): PrivateStateProvider<PSS> => {
  const config = _.defaults(partialConfig, DEFAULT_CONFIG);
  return {
    get<PSK extends PrivateStateKey<PSS>>(key: PSK): Promise<PSS[PSK] | null> {
      return subLevelMaybeGet<PSK, PSS[PSK]>(
        config.midnightDbName,
        config.privateStateStoreName,
        key
      );
    },
    remove<PSK extends PrivateStateKey<PSS>>(key: PSK): Promise<void> {
      return withSubLevel<PSK, PSS[PSK], void>(
        config.midnightDbName,
        config.privateStateStoreName,
        (subLevel) => subLevel.del(key)
      );
    },
    set<PSK extends PrivateStateKey<PSS>>(key: PSK, state: PSS[PSK]): Promise<void> {
      return withSubLevel<PSK, PSS[PSK], void>(
        config.midnightDbName,
        config.privateStateStoreName,
        (subLevel) => subLevel.put(key, state)
      );
    },
    clear(): Promise<void> {
      return withSubLevel(config.midnightDbName, config.privateStateStoreName, (subLevel) =>
        subLevel.clear()
      );
    },
    getSigningKey<PSK extends PrivateStateKey<PSS>>(key: PSK): Promise<SigningKey | null> {
      return subLevelMaybeGet<PSK, SigningKey>(
        config.midnightDbName,
        config.signingKeyStoreName,
        key
      );
    },
    removeSigningKey<PSK extends PrivateStateKey<PSS>>(key: PSK): Promise<void> {
      return withSubLevel<PSK, SigningKey, void>(
        config.midnightDbName,
        config.signingKeyStoreName,
        (subLevel) => subLevel.del(key)
      );
    },
    setSigningKey<PSK extends PrivateStateKey<PSS>>(
      key: PSK,
      signingKey: SigningKey
    ): Promise<void> {
      return withSubLevel<PSK, SigningKey, void>(
        config.midnightDbName,
        config.signingKeyStoreName,
        (subLevel) => subLevel.put(key, signingKey)
      );
    },
    clearSigningKeys(): Promise<void> {
      return withSubLevel(config.midnightDbName, config.signingKeyStoreName, (subLevel) =>
        subLevel.clear()
      );
    }
  };
};
