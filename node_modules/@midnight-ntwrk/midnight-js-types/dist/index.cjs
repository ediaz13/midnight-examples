'use strict';

var ledger = require('@midnight-ntwrk/ledger');

/**
 * Creates a branded prover key representation from a prover key binary.
 *
 * @param uint8Array The prover key binary.
 */
const createProverKey = (uint8Array) => {
    return uint8Array;
};
/**
 * Creates a branded verifier key representation from a verifier key binary.
 *
 * @param uint8Array The verifier key binary.
 */
const createVerifierKey = (uint8Array) => {
    return uint8Array;
};
/**
 * Creates a branded ZKIR representation from a ZKIR binary.
 *
 * @param uint8Array The ZKIR binary.
 */
const createZKIR = (uint8Array) => {
    return uint8Array;
};
/**
 * Creates an {@link UnbalancedTransaction} from a ledger transaction.
 *
 * @param tx The ledger transaction to wrap.
 */
const createUnbalancedTx = (tx) => {
    return tx;
};
/**
 * Creates an {@link BalancedTransaction} from a ledger transaction.
 * @param tx The ledger transaction to wrap.
 */
const createBalancedTx = (tx) => {
    return tx;
};
/**
 * Indicates that the transaction is invalid.
 */
const FailEntirely = 'FailEntirely';
/**
 * Indicates that the transaction is valid but the portion of the transcript
 * that is allowed to fail (the portion after a checkpoint) did fail. All effects
 * from the guaranteed part of the transaction are kept but the effects from the
 * fallible part of the transaction are discarded.
 */
const FailFallible = 'FailFallible';
/**
 * Indicates that the guaranteed and fallible portions of the transaction were
 * successful.
 */
const SucceedEntirely = 'SucceedEntirely';

/**
 * A provider for zero-knowledge intermediate representations, prover keys, and verifier keys. All
 * three are used by the {@link ProofProvider} to create a proof for a call transaction. The implementation
 * of this provider depends on the runtime environment, since each environment has different conventions
 * for accessing static artifacts.
 * @typeParam K - The type of the circuit ID used by the provider.
 */
class ZKConfigProvider {
    /**
     * Retrieves the verifier keys produced by `compactc` for the given circuits.
     * @param circuitIds The circuit IDs of the verifier keys to retrieve.
     */
    async getVerifierKeys(circuitIds) {
        return Promise.all(circuitIds.map(async (id) => {
            const key = await this.getVerifierKey(id);
            return [id, key];
        }));
    }
    /**
     * Retrieves all zero-knowledge artifacts produced by `compactc` for the given circuit.
     * @param circuitId The circuit ID of the artifacts to retrieve.
     */
    async get(circuitId) {
        return {
            circuitId,
            proverKey: await this.getProverKey(circuitId),
            verifierKey: await this.getVerifierKey(circuitId),
            zkir: await this.getZKIR(circuitId)
        };
    }
}

Object.defineProperty(exports, 'UnprovenTransaction', {
    enumerable: true,
    get: function () { return ledger.UnprovenTransaction; }
});
exports.FailEntirely = FailEntirely;
exports.FailFallible = FailFallible;
exports.SucceedEntirely = SucceedEntirely;
exports.ZKConfigProvider = ZKConfigProvider;
exports.createBalancedTx = createBalancedTx;
exports.createProverKey = createProverKey;
exports.createUnbalancedTx = createUnbalancedTx;
exports.createVerifierKey = createVerifierKey;
exports.createZKIR = createZKIR;
//# sourceMappingURL=index.cjs.map
