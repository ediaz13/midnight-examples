"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_os_1 = __importDefault(require("node:os"));
const node_path_1 = require("node:path");
const node_process_1 = __importDefault(require("node:process"));
const strip_ansi_1 = __importDefault(require("strip-ansi"));
const allure_js_commons_1 = require("allure-js-commons");
const AllureJestApi_1 = require("./AllureJestApi");
const utils_1 = require("./utils");
const { ALLURE_HOST_NAME, ALLURE_THREAD_NAME, JEST_WORKER_ID } = node_process_1.default.env;
const hostname = node_os_1.default.hostname();
const createJestEnvironment = (Base) => {
    return class extends Base {
        constructor(config, context) {
            var _a;
            super(config, context);
            this.runningTests = new Map();
            this.handleTestEvent = (event, state) => {
                switch (event.name) {
                    case "add_test":
                        this.handleTestAdd({
                            testName: event.testName,
                            concurrent: event.concurrent,
                            state,
                        });
                        break;
                    case "test_start":
                        this.handleTestStart(event.test);
                        break;
                    case "test_todo":
                        this.handleTestTodo(event.test);
                        break;
                    case "test_fn_success":
                        this.handleTestPass(event.test);
                        break;
                    case "test_fn_failure":
                        this.handleTestFail(event.test);
                        break;
                    case "test_skip":
                        this.handleTestSkip(event.test);
                        break;
                    case "test_done":
                        this.handleTestDone(event.test);
                        break;
                    default:
                        break;
                }
            };
            const { resultsDir = "allure-results", links = [], testMode = false, } = ((_a = config === null || config === void 0 ? void 0 : config.projectConfig) === null || _a === void 0 ? void 0 : _a.testEnvironmentOptions) || {};
            this.runtime = new allure_js_commons_1.AllureRuntime({
                resultsDir: resultsDir,
                writer: testMode ? new allure_js_commons_1.MessageAllureWriter() : undefined,
            });
            this.linksMatchers = links;
            this.global.allure = new AllureJestApi_1.AllureJestApi(this, this.global);
            this.testPath = context.testPath.replace(config.globalConfig.rootDir, "").replace(node_path_1.sep, "");
        }
        setup() {
            return super.setup();
        }
        teardown() {
            return super.teardown();
        }
        transformLinks(links) {
            return links.map((link) => {
                const matcher = this.linksMatchers.find((m) => m.type === link.type);
                if (!matcher || link.url.startsWith("http")) {
                    return link;
                }
                return Object.assign(Object.assign({}, link), { url: matcher.urlTemplate.replace("%s", link.url) });
            });
        }
        handleAllureMetadata(payload) {
            const currentTest = this.runningTests.get(payload.currentTestName);
            currentTest.applyMetadata(payload.metadata);
        }
        handleTestAdd(payload) {
            const { testName, state } = payload;
            const { currentDescribeBlock } = state;
            const newTestSuitesPath = (0, utils_1.getTestPath)(currentDescribeBlock);
            const newTestPath = newTestSuitesPath.concat(testName);
            const newTestId = (0, utils_1.getTestId)(newTestPath);
            const newTest = new allure_js_commons_1.AllureTest(this.runtime);
            const threadLabel = ALLURE_THREAD_NAME || JEST_WORKER_ID || node_process_1.default.pid.toString();
            const hostLabel = ALLURE_HOST_NAME || hostname;
            const packageLabel = (0, node_path_1.dirname)(this.testPath).split(node_path_1.sep).join(".");
            newTest.name = testName;
            newTest.fullName = newTestId;
            newTest.addLabel(allure_js_commons_1.LabelName.LANGUAGE, "javascript");
            newTest.addLabel(allure_js_commons_1.LabelName.FRAMEWORK, "jest");
            newTest.addLabel(allure_js_commons_1.LabelName.PACKAGE, packageLabel);
            if (threadLabel) {
                newTest.addLabel(allure_js_commons_1.LabelName.THREAD, threadLabel);
            }
            if (hostLabel) {
                newTest.addLabel(allure_js_commons_1.LabelName.HOST, hostLabel);
            }
            (0, allure_js_commons_1.getSuitesLabels)(newTestSuitesPath).forEach((label) => {
                newTest.addLabel(label.name, label.value);
            });
            if (this.runningTests.has(newTestId)) {
                console.error(`Test "${newTestId}" has been already initialized! To continue with reporting, please rename the test.`);
                return;
            }
            this.runningTests.set(newTestId, newTest);
        }
        handleTestStart(test) {
            const currentTestId = (0, utils_1.getTestId)((0, utils_1.getTestPath)(test));
            const currentTest = this.runningTests.get(currentTestId);
            if (!currentTest) {
                console.error(`Can't find "${currentTestId}" test while tried to start it!`);
                return;
            }
            currentTest.stage = allure_js_commons_1.Stage.RUNNING;
        }
        handleTestPass(test) {
            const currentTestId = (0, utils_1.getTestId)((0, utils_1.getTestPath)(test));
            const currentTest = this.runningTests.get(currentTestId);
            if (!currentTest) {
                console.error(`Can't find "${currentTestId}" test while tried to mark it as passed!`);
                return;
            }
            currentTest.stage = allure_js_commons_1.Stage.FINISHED;
            currentTest.status = allure_js_commons_1.Status.PASSED;
        }
        handleTestFail(test) {
            var _a, _b;
            const currentTestId = (0, utils_1.getTestId)((0, utils_1.getTestPath)(test));
            const currentTest = this.runningTests.get(currentTestId);
            if (!currentTest) {
                console.error(`Can't find "${currentTestId}" test while tried to mark it as failed!`);
                return;
            }
            const [error] = test.errors;
            const hasMultipleErrors = Array.isArray(error);
            const errorMessage = (hasMultipleErrors ? (_a = error[0]) === null || _a === void 0 ? void 0 : _a.message : error.message);
            const errorTrace = (hasMultipleErrors ? (_b = error[0]) === null || _b === void 0 ? void 0 : _b.stack : error.stack);
            currentTest.stage = allure_js_commons_1.Stage.FINISHED;
            currentTest.status = allure_js_commons_1.Status.FAILED;
            currentTest.statusDetails = {
                message: (0, strip_ansi_1.default)(errorMessage || ""),
                trace: (0, strip_ansi_1.default)(errorTrace || ""),
            };
        }
        handleTestSkip(test) {
            const currentTestId = (0, utils_1.getTestId)((0, utils_1.getTestPath)(test));
            const currentTest = this.runningTests.get(currentTestId);
            if (!currentTest) {
                console.error(`Can't find "${currentTestId}" test while tried to mark it as skipped!`);
                return;
            }
            currentTest.stage = allure_js_commons_1.Stage.PENDING;
            currentTest.status = allure_js_commons_1.Status.SKIPPED;
            currentTest.calculateHistoryId();
            currentTest.endTest();
            this.runningTests.delete(currentTestId);
        }
        handleTestDone(test) {
            const currentTestId = (0, utils_1.getTestId)((0, utils_1.getTestPath)(test));
            const currentTest = this.runningTests.get(currentTestId);
            if (!currentTest) {
                console.error(`Can't find "${currentTestId}" test while tried to dispose it after start!`);
                return;
            }
            currentTest.calculateHistoryId();
            currentTest.endTest();
            this.runningTests.delete(currentTestId);
        }
        handleTestTodo(test) {
            const currentTestId = (0, utils_1.getTestId)((0, utils_1.getTestPath)(test));
            const currentTest = this.runningTests.get(currentTestId);
            if (!currentTest) {
                console.error(`Can't find "${currentTestId}" test while tried to mark it as todo!`);
                return;
            }
            currentTest.stage = allure_js_commons_1.Stage.PENDING;
            currentTest.status = allure_js_commons_1.Status.SKIPPED;
            currentTest.calculateHistoryId();
            currentTest.endTest();
            this.runningTests.delete(currentTestId);
        }
    };
};
exports.default = createJestEnvironment;
//# sourceMappingURL=AllureJest.js.map